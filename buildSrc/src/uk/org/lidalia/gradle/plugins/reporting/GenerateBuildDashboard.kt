package uk.org.lidalia.gradle.plugins.reporting

import groovy.lang.Closure
import org.gradle.api.Action
import org.gradle.api.DefaultTask
import org.gradle.api.internal.CollectionCallbackActionDecorator
import org.gradle.api.reporting.BuildDashboardReports
import org.gradle.api.reporting.Report
import org.gradle.api.reporting.ReportContainer
import org.gradle.api.reporting.Reporting
import org.gradle.api.reporting.internal.BuildDashboardGenerator
import org.gradle.api.reporting.internal.DefaultBuildDashboardReports
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.Nested
import org.gradle.api.tasks.TaskAction
import org.gradle.internal.reflect.Instantiator
import org.gradle.util.ClosureBackedAction
import java.io.File
import java.io.Serializable
import javax.inject.Inject

/**
 * Generates build dashboard report.
 */
@Suppress("unused")
open class GenerateBuildDashboard : DefaultTask(), Reporting<BuildDashboardReports> {

  private val aggregated: MutableSet<Reporting<out ReportContainer<*>>> = LinkedHashSet()
  private val reports: BuildDashboardReports

  init {
    @Suppress("LeakingThis")
    reports = getInstantiator().newInstance(
      DefaultBuildDashboardReports::class.java,
      this,
      getCollectionCallbackActionDecorator()
    )
    reports.html.isEnabled = true
  }

  @Inject
  protected open fun getInstantiator(): Instantiator {
    throw UnsupportedOperationException()
  }

  @Inject
  protected open fun getCollectionCallbackActionDecorator(): CollectionCallbackActionDecorator {
    throw UnsupportedOperationException()
  }

  @get:Input
  val inputReports: Set<ReportState>
    get() = (enabledInputReports - reports)
        .map { report ->
          ReportState(
            name = report.displayName,
            destination = report.destination,
            available = report.destination.exists()
          )
        }
        .toSet()

  private val enabledInputReports: Set<Report>
    get() =
      (aggregated + aggregatedTasks)
        .flatMap { it.reports.enabled }
        .toSet()

  private val aggregatedTasks: Set<Reporting<out ReportContainer<*>>>
    get() {
      val reports: MutableSet<Reporting<out ReportContainer<*>>> = mutableSetOf()
      project.allprojects {
        project.tasks
          .filterIsInstanceTo(reports, Reporting::class.java)
      }
      return reports
    }

  /**
   * Configures which reports are to be aggregated in the build dashboard report generated by this task.
   *
   * <pre>
   * buildDashboard {
   *   aggregate codenarcMain, checkstyleMain
   * }
   * </pre>
   *
   * @param reportings an array of [Reporting] instances that are to be aggregated
   */
  @Suppress("unused")
  fun aggregate(vararg reportings: Reporting<out ReportContainer<*>>) {
    reportings.toCollection(aggregated)
  }

  /**
   * The reports to be generated by this task.
   *
   * @return The reports container
   */
  @Nested
  override fun getReports(): BuildDashboardReports = reports

  /**
   * Configures the reports to be generated by this task.
   *
   * The contained reports can be configured by name and closures.
   *
   * <pre>
   * buildDashboard {
   *   reports {
   *     html {
   *       destination "build/dashboard.html"
   *     }
   *   }
   * }
   * </pre>
   *
   * @param closure The configuration
   * @return The reports container
   */
  override fun reports(closure: Closure<*>): BuildDashboardReports = reports(ClosureBackedAction(closure))

  /**
   * Configures the reports to be generated by this task.
   *
   * The contained reports can be configured by name and closures.
   *
   * <pre>
   * buildDashboard {
   *   reports {
   *     html {
   *       destination "build/dashboard.html"
   *     }
   *   }
   * }
   * </pre>
   *
   * @param configureAction The configuration
   * @return The reports container
   */
  override fun reports(configureAction: Action<in BuildDashboardReports>): BuildDashboardReports {
    configureAction.execute(reports)
    return reports
  }

  @TaskAction
  fun run() {
    if (reports.html.isEnabled) {
      val generator = BuildDashboardGenerator()
      generator.render(enabledInputReports, reports.html.entryPoint)
    } else {
      didWork = false
    }
  }

  data class ReportState internal constructor(
    private val name: String,
    private val destination: File,
    private val available: Boolean
  ) : Serializable
}
